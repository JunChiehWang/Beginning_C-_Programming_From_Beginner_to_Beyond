We've seen how we can attempt to write generic functions using preprocessor macros in this video we'll
see how we can you see post plus templates to accomplish writing generic functions.
So what is a C++ template.
A template is a generic blueprint that the compiler uses to generate specialized functions and classes
as I just said C++ supports function and class templates.
In this video we'll learn about function templates and more C-Class templates in the next video.
The idea with templates is that we define a template with a placeholder type and then we plug in the
actual type we want when we need it.
Then the compiler generates the specific function or class that we need.
Remember all of this happens at compile time.
If you're coming from other programming languages you might be used to this happening at runtime.
C++ does it at compile time.
So we get the benefit of the compiler performing type checking for us before the program executes C++
template supports the concept of generic programming or metaprogramming.
Since we're providing a generic representation of a function or class and then the compiler writes the
actual function or class for us.
That's very very powerful However with power comes complexity C++ templates can be very very complex.
And while the concept is easy to understand seeing them in practice can sometimes be very intimidating
even for experienced programmers.
Also the error message is provided by the compiler can be very difficult to understand.
So let's see how we can use function templates with the Max function that we used in the previous video.
Let's quickly review we want to write a max function that returns the maximum of two integers passed
into it.
We can use a simple conditional expression which if you recall is equivalent to an if else statement.
Now we can simply use the max function in passing integers and get back the max of those integers.
Now suppose we need a max function for doubles and another for characters.
Then we could have another one for floats and longs you get the idea.
We could end up writing many of these max functions just as we saw in the previous lecture.
The code is the same for all of them.
It's the code with the conditional operator.
The only thing that changes are the types of the parameters.
So now let's see how we can use templates to allow us to write just one blueprint for this function.
Why don't we simply replace the type with an identifier that represents any type.
In this case we use the uppercase t but we can use any valid identifier we wish.
So that's it.
That was easy.
That's what we want right.
Yes indeed but the compiler won't know what to do with this and it's going to give us a compiler error.
We need to explicitly tell the compiler that this is a template function so let's do that in the next
slide.
Notice that now we provide the compiler with the line template and type name T in angle brackets.
That's the template parameter type.
This tells the compiler that T is the type name that will be replaced with whatever the user needs.
Now this will compile but it will not generate any code.
Let me say that again this will not generate any code.
It's simply a template or a blueprint.
Code is not generated by the compiler until the user uses a specialized version of the template.
I'll show you how to do that a second.
But first I want you to know that we can use the reserve word type name or class in templates.
They are essentially equivalent.
I will use type name in this course but you'll see both type name and class in production code.
So please be aware of that.
OK so now how do we use this template function.
Notice the code in the slide we declared two integers a and b and initialize them.
Then we call Max with a and b as parameters but also notice the template parameter we're using.
That's the end in angle brackets.
This gives the compiler all the information it needs to actually generate a specialized function from
the template we created using it in place of T.
The syntax should look familiar.
We used it previously when we created vectors and smart pointers.
You guessed it.
Vector unique pointers shared pointers and so forth are implemented as template classes.
Now suppose we need a max function for doubles easy.
We simply use max and passen to doubles.
Say C and D.
And use a template parameter double in the angle brackets.
The compiler now knows that it needs to generate the double version of the Max function.
Often the compiler can deduce the type of the template parameter and we don't even need to provide it
as in the second statement.
How cool is that.
And that makes it even easier and we don't have to stop with doubles if we need to compare two characters
and return the max character we can simply use the template function Max with chars and the compiler
will generate the character version of the Max function.
We can use almost any type we need.
Notice I said almost what do I mean by almost any type.
Well let's take a closer look at the function again and you'll see what I mean.
Notice that the code in the template function is using the Greater than operator to compare A and B.
This means that whatever type we use for T must support this operator.
For primitive types like ints in chars and doubles it's not a problem.
But for our own class types we have to be sure that our class overloads the Greater than operator.
Or this won't compile.
In this example we're assuming we have a player class and we're using max with player objects so the
compiler will generate the max function that expects and compares player objects unless the player class
overloads the Greater than operator.
This code won't compile there is no limit to the number of template parameters you can have.
And of course they can be of different types.
In this example we're creating a function template for a function named fuck it expects two parameters.
The first is of type T one and the second is of type 2.
Notice that we specify two template parameters in this case.
So there is the function declaration.
Now let's see how we would use it.
We can call func and explicitly provide an integer and a double in this example or in the case of the
call to fuck with no template parameters the compiler will deduce the types from the function arguments
that's it.
Now of course we can pass by value by reference by pointer with Konst modifiers and so forth and all
of the function parameters don't have to be generic.
You can see all the possibilities and combinations.
Now let's head over to the idea and write a few template functions.
Ok so I'm in the section 20 workspace in the function templates project and what I'd like to do here
is go over those two templates that we created in the slides and I'll show you how they work with integers
with doubles with characters.
Basically with primitive types where there are no issues with overloading operators then what we'll
do is create our own type.
We'll call it person or something like that.
And then you'll see some of the issues that we have to address to get that person class or structure
in this case to work with these templates.
And then what we'll do is we'll create a swap template function at the end.
All right so let's go over what we've got here.
Now if you recall we've got a function called men and it's a template function right.
So there's my template parameter Tepe.
And basically if you write this with ints instead of T's it's really really easy and all you need to
do is replace it with the generic type T.
The compiler will take care of the rest so it's going to be an array of type T A B of type T is what
it expects and is going to return a type T and all we're doing is comparing using less than.
Now here's where the issue is.
If we're using integers here then assuming a and b are integers then the less sand works great right.
We know how to compare integers and doubles in characters and so forth.
But when we use our own types.
That's where the issue comes in and I'll talk about that in a second.
But first let's just look at a real simple example of using it and then we'll look at this template
function right here next.
Remember at this point the compiler has done nothing for us.
It hasn't all it's done is made sure that this is valid but it has not created an integer version of
this or double version of this.
Nothing gets created it's just a blueprint right now.
So what we've got here is right here on line 18.
You can see that I'm calling men and I'm using the template parameter int that I'm passing into integers
at this point.
The compiler now sees this blueprint and generates the integer version of it.
So t would be it.
Now when I set this whole template stuff gets taken away and we just get a function that just like we
wrote in the slides were just plain integers.
So in this case I expect that result to be a 2 because that's the minimal.
Now go also notice right here on line 19 that I'm not providing this template parameter right here.
You see it's just min to come up 3.
The compiler is smart enough to deduce that these these are integers.
So it's going to create the integer version of it.
A lot of times the compiler will figure it out.
Other times the compiler won't figure it out.
Depending on how complex the template function is.
So in this case you can figure it out.
So all I need to do is just call min pass in a two or three and I'll get a two.
Just like before.
Now here you can see I'm calling men with two characters a and b in this case their literals.
Does it really matter in this.
They're all literals in these examples but it doesn't really matter if they're literals or variables
that will all work the same.
The compiler will now see aha.
Two characters here so it will deduce that this template parameter right here is a character and it
would generate the character version of that template function.
Will get an A right here when we display it.
Same thing with one with the doubles here twelve point five 9.2.
A double version of the function will get created by the compiler and in the very end here we've got
integers.
But this is a real difference between the template functions and macros.
We don't have to worry about precedence or anything here.
We just do what we need to do we want five plus four.
We don't have to worry about C-style macros that we did before with the pound defined in the previous
video.
This is going to work correctly and because the compiler knows C++ So that's it.
If we run this we should get what we expect.
So let me build and run and hear my results right here and just roll them a bit up right here.
And that's just what we expected a two or two and a nine point two and nine.
What we'll do now is we'll create our own structure.
Now this can be any it could be a class.
I'm just going to create a structure so don't have to worry about private and public but it work exactly
the same way with a class.
So right here I'm going to create a structure and I'm going to call in person and I'm just going to
say that every person has a name which is a string a C++ string and an age.
That's it.
There is my person that misspell struct correctly.
It's a structure since I can create person objects right.
So let's do that and I'm going to do it up here right about here.
I am going to say person P1.
And remember I've got a string right here name and I've got an age.
So my first person will be curly and it's say that Curley's 50 years old and my second person is Mo
and Mo is 30 years old and it keeps giving me that curly I'll get rid of that.
OK so now I've got two person objects so what I want now is I want the minimum of those to write.
I want to be able to use my mind function that I wrote to be generic so it should expect any type that
makes sense.
Well here it doesn't quite make sense yet but it will in a minute because what I want to do is I want
to compare their ages.
So let's just say Person p 3 is the minimum of P1 and P2.
In other words men with the least age.
Now if we try to compile this we're going to get an error and the error if you can see that here is
his error.
No match for operator less than for the operand types person person.
So you can see that the compiler has generated that specialized function for the persons.
But now it can't compile that because it doesn't know how to compare two persons using that less than
can.
So what do we do.
Well we tell the compiler how do you how to do that.
So what we'll do is simply write a real simple overloaded operator.
Remember that return boolean.
The operator is operator less than that's the one that's causing the problem.
And what does it expect.
Well remember this is a member.
So we're going to say Konst person ref right hand side ofI has remembered this part of the Course and
its cause because I really don't want to modify anything here and all I'm doing here is I'm just saying
I want to return this person's age.
Is it less than the other person's age.
That's it.
So if I run this now.
Now we've got a clean run right.
We just need to display the result which we haven't done yet.
So I want to do that right here and I'll just say something like stood out and I'll just say P 3.0 name
is younger.
That's it.
So if we run this at this point we suit see Mo right we should say Mo is younger let's run the there
we go.
Mo is younger so let's change the around now let's say that Curley's 15 and Mo is 13 and we should say
Kerley is younger.
And that's exactly what's going on.
OK.
So that's pretty cool.
I am able to use persons and integers and doubles and all kinds of stuff right.
And in this case I'm really explicitly saying that I'm interested in comparing ages here.
OK so now let's look at this second example right here and this is when using two template parameters
we're here on line 11.
Our function is called phunk it expects two parameters and a B is of type 2 1 B is of type 2 they can
be the same or they can be different.
And all we're doing is just displaying a and b that's it real simple.
So let's take a look at our main example down here.
There's a bunch of test cases here but you can see in this case I'm explicitly providing the template
parameters in that first example right here.
And you can see that I've got two ants and I'm supplying those two.
So we just expect this all this function does is display what's passed into it.
So it'll display 10 or 20.
Then we can do the same thing.
But in this case the compiler is deducing the types.
Notice I'm not providing them explicitly here or providing a character in a double explicitly here I'm
just letting the compiler deduce it.
And again here's an integer Here's a C string.
Here's an integer Here's AC plus plus string.
So I'm passing all kinds of stuff into this function and the compiler is going to generate the correct
one for me which is really cool.
So if I run this you could see down here we're getting a 10 and a 20 and a 10 and a 20 again and the
A and the twelve point four twice I'm getting that then I'm seeing a thousand testing in 2000 Frank.
Exactly like we expected.
OK so now let me scroll up here just before mine 31 right here.
And what I'd like to do here is let's call Phunk with a person or two persons.
Doesn't really matter.
Remember it's expecting two different types or two types that are the same.
So let's do that let's call func with P1 and P2.
Now when we try to compile here we're going to have a problem.
It says error or no match for the insertion operator that expects a stream.
And if I come over here just a little bit and a person what's the problem.
Well the problem is that in this case a is a person and there is no overloaded insertion operator for
a person.
So that won't work.
So what we want to do is we want to add the overloaded insertion operator and we can do that really
easily could do it right here.
We don't need a friend function here because this is all it's a structure.
So everything public.
So that we can do is we could just say stood stream remember this and who are returning and stream reference
and what we're going to do here is its operator and we're doing the insertion operator the left hand
side is the stream and we don't want to do that conc because we want to change it.
Now the right hand side is the person.
So in this case it's a contact person reference and call it P.
So what do we want to put on the stream.
Well we could just say yes and the states please name it makes it really easy and we want to return
the stream.
That's it.
We run this now.
Now we get Kirtley and Moe noticed they're both pretty out right here.
That's exactly what we wanted.
So this is one of the things that will get you when you first starting out with template functions is.
Yeah I can supply any kind of type to it for sure but a lot of times when you're using operators you've
got to really be careful with those operators to make sure that they work correctly.
Overload them if you have to.
OK so now the last thing I want to do is let's create another template function and will read it right
down here right before the main.
And what we'll do is we'll just call it my swap and I just want to swap two elements right.
So how would we do this with an end.
I would say something like.
Int Oh sorry.
Oh just something like void and we'll call it my swap.
It expects to integers.
Now we want to change them so we really want them by reference.
And here's the second one.
And then in here all we're doing is assigning temporary right so we have an int temp equals A then A
equals B and then be equal temperament.
Simple swap simple simple logic that'll work.
That'll swap two integers but we don't just want to swap integers.
We want to swap anything.
So what we can do here is we can come to this it replace it with a T.
Replace this guy with a T and replace that guy with a T.
And remember that could be any letter I'm just using T.
So now we'll tell the compiler This is a template function and its type name is T.
That's it.
Now we've got a template function called my swamp.
That's pretty cool.
Now I'll do it appear.
So we'll see that is the first output.
And what we can do here is we can just say ant X is 100 into Y is 200 and we can swap them.
Right so that's X and Y if we displayed x and y we'd obviously get 100 200 but now we can call my swap
and we can pass in X and Y.
And at this point what I want to do is just display X and Y so I'll copy that in here real quick.
That's it.
It's going to display X and Y what I expect now is 200 100 right.
I see you know what let me put this before and after the swap that way it'll be really really obvious
what's going on.
That's it right here so if I run this now you could see 100 200 at the top and then 200 100 which swap
them.
Now the cool thing about that I can write this with strings characters all kinds of good stuff right.
And I'll leave that to you guys to play because this video is getting a little bit long try replacing
some of these with your own types and playing around with it you'll see it's not so bad once you understand
the basics of template functions.
You'll see how powerful they are.
But remember there's those little gotchas if you get those errors are typically about operators that
the compiler can't resolve.
So it's your job to resolve them.
OK.
So that's it for template functions in the next video will start talking about template classes.
